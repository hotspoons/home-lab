DOMAIN=${domain}
CLOUDFLARE_GLOBAL_API_KEY=${cloudflare_global_api_key}
CLOUDFLARE_EMAIL=${cloudflare_email}
MASTER_HOSTNAME=${master_hostname}
## NFS Configuration - set NFS server and path for dynamic storage for persistent volumes
NFS_SERVER=${nfs_server}
NFS_PATH=${nfs_path}
NFS_PROVISION_NAME=${nfs_provision_name}
PI_HOLE_SERVER=${pi_hole_server}
PI_HOLE_PASSWORD=${pi_hole_password}
## IP Address range for load balancer
START_IP=${start_ip}
END_IP=${end_ip}
VIP_IP=${vip_ip}
GITLAB_IP=${gitlab_ip}
SETUP_VIP_LB=${setup_vip_lb}
SETUP_NFS_PROVISIONER=${setup_nfs_provisioner}
SETUP_TLS_SECRETS=${setup_tls_secrets}
SETUP_CERT_MANAGER=${setup_cert_manager}
SETUP_GITLAB=${setup_gitlab}
SETUP_PIHOLE_DNS=${setup_pihole_dns}
SETUP_DEV_TOOLS=${setup_dev_tools}
SETUP_WASM=${setup_wasm}

KUBE_VIP_URL=https://raw.githubusercontent.com/kube-vip/kube-vip-cloud-provider/main/manifest/kube-vip-cloud-controller.yaml
KUBE_VIP_RBAC_URL=https://kube-vip.io/manifests/rbac.yaml
NFS_HELM_REPO=https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/
GO_URL=https://go.dev/dl/go1.21.1.linux-amd64.tar.gz
MANIFEST_FOLDER=/tmp/manifests
### TODO - add flags to enable/disable features in config

export KUBECONFIG=/etc/kubernetes/admin.conf

################################################
## Unzip and any manifests                    ##
################################################

cd $MANIFEST_FOLDER
unzip manifests.zip
cd /tmp


################################################
## Import any secrets passed in on cloudinit  ##
################################################

if [[ -d "$MANIFEST_FOLDER/secrets" ]]; then
  for manifest in $MANIFEST_FOLDER/secrets/*.yaml; do
    kubectl apply -f $manifest
  done
fi

################################################
## Configure Kube VIP Load Balancer           ##
################################################

if [[ -n "$SETUP_VIP_LB" ]]; then

kubectl get configmap -n kube-system kube-proxy -o yaml > /tmp/proxy.yaml
sed -i 's/strictARP: false/strictARP: true/g' /tmp/proxy.yaml
kubectl replace -f /tmp/proxy.yaml

kubectl apply -f $KUBE_VIP_URL
kubectl apply -f $KUBE_VIP_RBAC_URL
kubectl create configmap -n kube-system kubevip --from-literal range-global=$START_IP-$END_IP
INTERFACE=$(ip route get 8.8.8.8 | sed -n 's/.*dev \([^\ ]*\).*/\1/p')
KVVERSION=$(curl -sL https://api.github.com/repos/kube-vip/kube-vip/releases | jq -r ".[0].name" | xargs)
ctr image pull "ghcr.io/kube-vip/kube-vip:$KVVERSION"
ctr run --rm --net-host "ghcr.io/kube-vip/kube-vip:$KVVERSION" vip "/kube-vip" manifest daemonset \
  --interface $INTERFACE \
  --address $VIP_IP --inCluster --taint --controlplane \
  --services --arp --leaderElection | tee kubevip.yaml
kubectl apply -f kubevip.yaml

if [[ -d "$MANIFEST_FOLDER/lb" ]]; then
  for manifest in $MANIFEST_FOLDER/lb/*.yaml; do
    kubectl apply -f $manifest
  done
fi

fi

################################################
## Configure auto-provisioned NFS storage     ##
################################################

if [[ -n "$SETUP_NFS_PROVISIONER" || -n "$SETUP_GITLAB" ]]; then

helm repo add nfs-subdir-external-provisioner $NFS_HELM_REPO
helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \
    --set nfs.server=$NFS_SERVER \
    --set nfs.path=$NFS_PATH \
    --set persistence.enabled=true \
    --set storageClass.defaultClass=true

if [[ -d "$MANIFEST_FOLDER/pvs" ]]; then
  for manifest in $MANIFEST_FOLDER/pvs/*.yaml; do
    kubectl apply -f $manifest
  done
fi

fi

################################################
## Create TLS secret from certs               ##
################################################

if [[ -n "$SETUP_TLS_SECRETS" ]]; then
  
kubectl create secret tls $DOMAIN-tls --cert=/etc/ssl/$DOMAIN/fullchain.pem --key=/etc/ssl/$DOMAIN/privkey.pem
echo "Created SSL secret: $DOMAIN-tls"

fi

################################################
## Configure certificate manager via CloudFlare#
################################################

if [[ -n "$SETUP_CERT_MANAGER" ]]; then

helm repo add jetstack https://charts.jetstack.io
helm repo update

helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.13.0 \
  --set installCRDs=true \
  --set webhook.timeoutSeconds=20

cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: cloudflare-api-key-secret
  namespace: cert-manager
type: Opaque
stringData:
  api-key: $CLOUDFLARE_GLOBAL_API_KEY
EOF

cat << EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-issuer
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: $CLOUDFLARE_EMAIL
    privateKeySecretRef:
      name: letsencrypt-private-key
    solvers:
    - dns01:
        cloudflare:
          email: $CLOUDFLARE_EMAIL
          apiKeySecretRef:
            name: cloudflare-api-key-secret
            key: api-key
EOF


cat << EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-cert
spec:
  secretName:   
  dnsNames:
  - "*.$DOMAIN"
  issuerRef:
    name: letsencrypt-issuer
    kind: ClusterIssuer
EOF

if [[ -d "$MANIFEST_FOLDER/cert-manager" ]]; then
  for manifest in $MANIFEST_FOLDER/cert-manager/*.yaml; do
    kubectl apply -f $manifest
  done
fi

fi

################################################
## Pi-hole external DNS                        #
################################################

if [[ -n "$SETUP_PIHOLE_DNS" ]]; then

kubectl create secret generic pihole-password \
  --from-literal EXTERNAL_DNS_PIHOLE_PASSWORD="$PI_HOLE_PASSWORD"

cat << EOF | kubectl apply -f -
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: external-dns
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: external-dns
rules:
- apiGroups: [""]
  resources: ["services","endpoints","pods"]
  verbs: ["get","watch","list"]
- apiGroups: ["extensions","networking.k8s.io"]
  resources: ["ingresses"]
  verbs: ["get","watch","list"]
- apiGroups: [""]
  resources: ["nodes"]
  verbs: ["list","watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: external-dns-viewer
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: external-dns
subjects:
- kind: ServiceAccount
  name: external-dns
  namespace: default
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: external-dns
spec:
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: external-dns
  template:
    metadata:
      labels:
        app: external-dns
    spec:
      serviceAccountName: external-dns
      containers:
      - name: external-dns
        image: registry.k8s.io/external-dns/external-dns:v0.13.5
        envFrom:
        - secretRef:
            name: pihole-password
        args:
        - --source=service
        - --source=ingress
        - --registry=noop
        - --policy=upsert-only
        - --provider=pihole
        - --pihole-tls-skip-verify
        - --pihole-server=http://$PI_HOLE_SERVER
      securityContext:
        fsGroup: 65534 # For ExternalDNS to be able to read Kubernetes token files
EOF

fi

################################################
## GitLab et al.                               #
################################################

if [[ -n "$SETUP_GITLAB" ]]; then

function get_pv_label_arg () {
  PV="$(kubectl get pv -A -l "selector=$1" -o yaml | yq '.items[0]')"
  if [[ "$PV" != "null" ]]; then
    echo " --set $2.persistence.matchLabels.selector=$1"
  fi
}


if [[ -n "$SETUP_CERT_MANAGER" ]]; then

# If we have gitlab certs from a previous installation, use them instead of issuing new certs
if [[ -d "$MANIFEST_FOLDER/gitlab-certs" ]]; then
  for manifest in $MANIFEST_FOLDER/gitlab-certs/*.yaml; do
    kubectl apply -f $manifest
  done

else

cat << EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: gitlab-cert
spec:
  secretName: gitlab-cert-tls
  dnsNames:
  - "gitlab.$DOMAIN"
  - "registry.$DOMAIN"
  - "minio.$DOMAIN"
  - "kas.$DOMAIN"
  issuerRef:
    name: letsencrypt-issuer
    kind: ClusterIssuer
EOF

fi

  export INGRESS_CERT_ARG="--set global.ingress.tls.secretName=gitlab-cert-tls"

elif [[ -n "$SETUP_TLS_SECRETS" ]]; then

  export INGRESS_CERT_ARG="--set global.ingress.tls.secretName=$DOMAIN-tls"

fi

cat << EOF | kubectl apply -f -
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: pd-gitlab
provisioner: cluster.local/nfs-subdir-external-provisioner
reclaimPolicy: Retain
volumeBindingMode: WaitForFirstConsumer
EOF

helm repo add gitlab https://charts.gitlab.io/

if [[ -n "$INGRESS_CERT_ARG" ]]; then

  helm upgrade --install gitlab gitlab/gitlab \
    --timeout 1800s \
    --set global.hosts.domain=$DOMAIN \
    --set global.edition=ce \
    --set global.hosts.externalIP=$GITLAB_IP \
    --set certmanager.install=false \
    --set global.ingress.configureCertmanager=false \
    --set postgresql.image.tag=13.6.0 \
    --set gitlab.gitaly.persistence.size=50Gi \
    --set gitlab.gitaly.persistence.storageClass=pd-gitlab $(get_pv_label_arg "repo-data-gitlab-gitaly-0" "gitlab.gitaly") \
    --set postgresql.persistence.size=8Gi \
    --set postgresql.persistence.storageClass=pd-gitlab $(get_pv_label_arg "data-gitlab-postgresql-0" "postgresql") \
    --set minio.persistence.size=10Gi \
    --set minio.persistence.storageClass=pd-gitlab $(get_pv_label_arg "gitlab-minio" "minio") \
    --set redis.persistence.size=5Gi \
    --set redis.persistence.storageClass=pd-gitlab $(get_pv_label_arg "redis-data-gitlab-redis-master-0" "redis") $INGRESS_CERT_ARG \

else

# If we don't have a cert from either CloudFlare or self-provided, use the default self-signed self-managed cert manager instead
  helm upgrade --install gitlab gitlab/gitlab \
    --timeout 1800s \
    --set global.hosts.domain=$DOMAIN \
    --set global.edition=ce \
    --set global.hosts.externalIP=$GITLAB_IP \
    --set certmanager-issuer.email=nobody@$DOMAIN \
    --set postgresql.image.tag=13.6.0 \
    --set gitlab.gitaly.persistence.size=50Gi \
    --set gitlab.gitaly.persistence.storageClass=pd-gitlab $(get_pv_label_arg "repo-data-gitlab-gitaly-0" "gitlab.gitaly") \
    --set postgresql.persistence.size=8Gi \
    --set postgresql.persistence.storageClass=pd-gitlab $(get_pv_label_arg "data-gitlab-postgresql-0" "postgresql") \
    --set minio.persistence.size=10Gi \
    --set minio.persistence.storageClass=pd-gitlab $(get_pv_label_arg "gitlab-minio" "minio") \
    --set redis.persistence.size=5Gi \
    --set redis.persistence.storageClass=pd-gitlab $(get_pv_label_arg "redis-data-gitlab-redis-master-0" "redis") \

fi

kubectl get service gitlab-nginx-ingress-controller -o yaml  > /tmp/ingress.yaml
sed -i 's/externalTrafficPolicy: Local/externalTrafficPolicy: Cluster/g' /tmp/ingress.yaml
kubectl replace -f /tmp/ingress.yaml

GITLAB_ROOT_PASSWORD=$(kubectl get secret gitlab-gitlab-initial-root-password -ojsonpath='{.data.password}' | base64 --decode)
echo "GitLab root password: $GITLAB_ROOT_PASSWORD"

fi

### debug distroless container example!: 
## kubectl -n cert-manager debug -it cert-manager-67576f4f5d-gz5l9 --image=migrulos/non-root-tools:1.7  --target=cert-manager-controller -- /bin/bash


################################################
## Dev tools, wasm shim                        #
################################################

if [[ -n "$SETUP_DEV_TOOLS" || -n "$SETUP_WASM" ]]; then
  cd /tmp
  dnf group install -y "Development Tools"
  wget $GO_URL
  tar -xvf go1.* -C /usr/local
  echo 'export GOROOT=/usr/local/go' | tee -a /etc/profile
  echo 'export PATH=$PATH:/usr/local/go/bin' | tee -a /etc/profile
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y 
  source "$HOME/.cargo/env"
  source /etc/profile

  if [[ -n "$SETUP_WASM" ]]; then

  git clone https://github.com/deislabs/containerd-wasm-shims.git
  cd containerd-wasm-shims/
  make

  fi
fi
