

## NFS Configuration - set NFS server and path for dynamic storage for persistent volumes
NFS_SERVER=${nfs_server}
NFS_PATH=${nfs_path}
NFS_PROVISION_NAME=${nfs_provision_name}
## IP Address range for load balancer
START_IP=${start_ip}
END_IP=${end_ip}
POD_NETWORK_CIDR=${pod_network_cidr}
MASTER_HOSTNAME=${master_hostname}
JOIN_CMD_PORT=${join_cmd_port}
JOIN_CMD_SALT=${join_cmd_salt}
VIP_IP=${vip_ip}
DOMAIN=${domain}
CLOUDFLARE_GLOBAL_API_KEY=${cloudflare_global_api_key}
CLOUDFLARE_EMAIL=${cloudflare_email}
KUBERNETES_VERSION=v1.28.2

### A lot of this is based on this article: https://www.linuxtechi.com/install-kubernetes-cluster-on-rocky-linux/
#Kubernetes utilities setup for persistent volumes, dashboard, and metal load balancer
DASHBOARD_URL=https://raw.githubusercontent.com/kubernetes/dashboard/master/aio/deploy/recommended.yaml
METALLB_HELM_REPO=https://metallb.github.io/metallb
NFS_HELM_REPO=https://kubernetes-sigs.github.io/nfs-subdir-external-provisioner/
CALICO_URL=https://raw.githubusercontent.com/projectcalico/calico/v3.26.1/manifests/calico.yaml
KUBE_VIP_URL=https://raw.githubusercontent.com/kube-vip/kube-vip-cloud-provider/main/manifest/kube-vip-cloud-controller.yaml
KUBE_VIP_RBAC_URL=https://kube-vip.io/manifests/rbac.yaml

################################################
## Setup firewall rules                       ##
################################################
firewall-cmd --zone=public --permanent --add-port={80,443,6443,2379,2380,10250,10251,10252,$JOIN_CMD_PORT}/tcp
firewall-cmd --zone=public --permanent --add-rich-rule "rule family=ipv4 source address=$(hostname -I |  awk '{print $1}')/32 accept"
firewall-cmd --zone=public --permanent --add-rich-rule "rule family=ipv4 source address=172.17.0.0/16 accept"
firewall-cmd --reload

## TODO - Firewall rules prevent kube-vip from operating, need to figure out which ports are needed
## for now we just disable to save frustration
systemctl stop firewalld.service

################################################
## Initialize cluster                         ##
################################################

## KUBERNETES_VERSION=$(kubectl version -o json | jq '.serverVersion.gitVersion' -r)

cat <<EOF > /tmp/kubeadm-config.yaml
kind: ClusterConfiguration
apiVersion: kubeadm.k8s.io/v1beta3
kubernetesVersion: $KUBERNETES_VERSION
---
kind: KubeletConfiguration
apiVersion: kubelet.config.k8s.io/v1beta1
cgroupDriver: cgroupfs
EOF

kubeadm init --config /tmp/kubeadm-config.yaml
mkdir -p /root/.kube
yes | cp /etc/kubernetes/admin.conf /root/.kube/config
chown $(id -u):$(id -g) /root/.kube/config
export KUBECONFIG=/etc/kubernetes/admin.conf
kubectl apply -f $CALICO_URL
systemctl restart containerd.service
#kubectl taint node $(hostname) node-role.kubernetes.io/control-plane:NoSchedule-
kubectl get nodes


############################################################################
## Setup secure-ish URL for joining nodes to the cluster, host and store  ##
############################################################################

mkdir -p /tmp/join-cluster/$JOIN_CMD_SALT
kubeadm token create --print-join-command > /tmp/join-cluster/$JOIN_CMD_SALT/join_kubernetes_cluster.sh

cd /tmp/join-cluster/

openssl req -new -newkey rsa:4096 -nodes -keyout snakeoil.key -out snakeoil.csr -subj /C=US/ST=State/L=Locality/O=None/OU=None/CN=*.$DOMAIN
openssl x509 -req -sha256 -days 365 -in snakeoil.csr -signkey snakeoil.key -out snakeoil.pem


###
echo "from http.server import HTTPServer, SimpleHTTPRequestHandler" >> server.py
echo "from ssl import PROTOCOL_TLS_SERVER, SSLContext" >> server.py
echo "import io, sys" >> server.py

echo "class DirectoryHandler(SimpleHTTPRequestHandler):" >> server.py
echo "    def list_directory(self, path):" >> server.py
echo "        f = io.BytesIO()" >> server.py
echo '        f.write("<!DOCTYPE html><html><body><h1>nothing to see here...</h1></body></html>".encode())' >> server.py
echo "        length = f.tell()" >> server.py
echo "        f.seek(0)" >> server.py
echo "        self.send_response(200)" >> server.py
echo "        encoding = sys.getfilesystemencoding()" >> server.py
echo "        self.send_header('Content-type', 'text/html; charset=%s' % encoding)" >> server.py
echo "        self.send_header('Content-Length', str(length))" >> server.py
echo "        self.end_headers()" >> server.py
echo "        return f" >> server.py
echo "" >> server.py
echo "ssl_context = SSLContext(PROTOCOL_TLS_SERVER)" >> server.py
echo "ssl_context.load_cert_chain('snakeoil.pem', 'snakeoil.key')" >> server.py
echo "server = HTTPServer(('0.0.0.0', $JOIN_CMD_PORT), DirectoryHandler)" >> server.py
echo "server.socket = ssl_context.wrap_socket(server.socket, server_side=True)" >> server.py
echo "server.serve_forever()" >> server.py

python3 server.py &

export CLUSTER_JOIN_URL="https://$MASTER_HOSTNAME:$JOIN_CMD_PORT/$JOIN_CMD_SALT/join_kubernetes_cluster.sh"

cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: cluster-join-url
type: Opaque
stringData:
  url: $CLUSTER_JOIN_URL
EOF

echo "Serving join command with salted URL over tls: $CLUSTER_JOIN_URL, also available as Kubernetes secret \"cluster-join-url\""

################################################
## Configure Kube VIP Load Balancer           ##
################################################


kubectl get configmap -n kube-system kube-proxy -o yaml > /tmp/proxy.yaml
sed -i 's/strictARP: false/strictARP: true/g' /tmp/proxy.yaml
kubectl replace -f /tmp/proxy.yaml

kubectl apply -f $KUBE_VIP_URL
kubectl apply -f $KUBE_VIP_RBAC_URL
kubectl create configmap -n kube-system kubevip --from-literal range-global=$START_IP-$END_IP
export INTERFACE=$(ip route get 8.8.8.8 | sed -n 's/.*dev \([^\ ]*\).*/\1/p')
KVVERSION=$(curl -sL https://api.github.com/repos/kube-vip/kube-vip/releases | jq -r ".[0].name")
shopt -s expand_aliases
alias kube-vip="ctr image pull ghcr.io/kube-vip/kube-vip:$KVVERSION; ctr run --rm --net-host ghcr.io/kube-vip/kube-vip:$KVVERSION vip /kube-vip"
kube-vip manifest daemonset \
  --interface $INTERFACE \
  --address $VIP_IP --inCluster --taint --controlplane \
  --services --arp --leaderElection | tee kubevip.yaml
kubectl apply -f kubevip.yaml

################################################
## Configure auto-provisioned NFS storage     ##
################################################
helm repo add nfs-subdir-external-provisioner $NFS_HELM_REPO
helm install nfs-subdir-external-provisioner nfs-subdir-external-provisioner/nfs-subdir-external-provisioner \
    --set nfs.server=$NFS_SERVER \
    --set nfs.path=$NFS_PATH \
    --set persistence.enabled=true \
    --set storageClass.defaultClass=true 

################################################
## Configure certificate manager via CloudFlare#
################################################

helm repo add jetstack https://charts.jetstack.io
helm repo update

helm install \
  cert-manager jetstack/cert-manager \
  --namespace cert-manager \
  --create-namespace \
  --version v1.13.0 \
  --set installCRDs=true \
  --set webhook.timeoutSeconds=20

cat << EOF | kubectl apply -f -
apiVersion: v1
kind: Secret
metadata:
  name: cloudflare-api-key-secret
type: Opaque
stringData:
  api-key: $CLOUDFLARE_GLOBAL_API_KEY
EOF

cat << EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-issuer
spec:
  acme:
    server: https://acme-v02.api.letsencrypt.org/directory
    email: $CLOUDFLARE_EMAIL
    privateKeySecretRef:
      name: letsencrypt-private-key
    solvers:
    - dns01:
        cloudflare:
          email: $CLOUDFLARE_EMAIL
          apiKeySecretRef:
            name: cloudflare-api-key-secret
            key: api-key
EOF


cat << EOF | kubectl apply -f -
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: wildcard-cert
spec:
  secretName: wildcard-cert-tls
  dnsNames:
  - "*.$DOMAIN"
  issuerRef:
    name: letsencrypt-private-key
    kind: ClusterIssuer
EOF

################################################
## Create TLS secret from certs               ##
################################################

kubectl create secret tls $DOMAIN-tls --cert=/etc/ssl/$DOMAIN/fullchain.pem --key=/etc/ssl/$DOMAIN/privkey.pem
echo "Created SSL secret: $DOMAIN-tls"

################################################
## Bash completion                            ##
################################################
kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl > /dev/null

# kubeadm reset -f && rm -rf /etc/cni/net.d && rm -f $HOME/.kube/config && docker system prune -a -f